import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { ArithmeticVault } from "../target/types/arithmetic_vault";
import { expect } from "chai";

describe("Arithmetic Overflow Vulnerability Tests", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.ArithmeticVault as Program<ArithmeticVault>;
  
  let vulnerableVault: anchor.web3.Keypair;
  let secureVault: anchor.web3.Keypair;
  let owner: anchor.web3.Keypair;
  let attacker: anchor.web3.Keypair;

  beforeEach(async () => {
    vulnerableVault = anchor.web3.Keypair.generate();
    secureVault = anchor.web3.Keypair.generate();
    owner = anchor.web3.Keypair.generate();
    attacker = anchor.web3.Keypair.generate();

    // Airdrop SOL to accounts
    await provider.connection.requestAirdrop(owner.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL);
    await provider.connection.requestAirdrop(attacker.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL);
    
    // Wait for airdrops to confirm
    await new Promise(resolve => setTimeout(resolve, 1000));
  });

  describe("Vulnerable Implementation - Overflow Exploits", () => {
    it("should demonstrate balance corruption through deposit overflow", async () => {
      // Initialize vault with a large balance near u64::MAX
      const nearMaxBalance = "18446744073709551615"; // u64::MAX
      const initialBalance = new anchor.BN(nearMaxBalance).sub(new anchor.BN(1000));
      
      await program.methods
        .vulnerableInitialize(initialBalance)
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([vulnerableVault, owner])
        .rpc();

      let vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Initial balance:", vaultAccount.balance.toString());

      // Attempt to deposit an amount that will cause overflow
      const overflowAmount = new anchor.BN(2000);
      
      await program.methods
        .vulnerableDeposit(overflowAmount)
        .accounts({
          vault: vulnerableVault.publicKey,
          depositor: attacker.publicKey,
        })
        .signers([attacker])
        .rpc();

      vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Balance after overflow deposit:", vaultAccount.balance.toString());
      
      // In release mode, this would wrap around to a small number
      // The exact behavior depends on compilation mode, but demonstrates the vulnerability
      expect(vaultAccount.balance.toString()).to.not.equal(initialBalance.add(overflowAmount).toString());
    });

    it("should demonstrate balance corruption through withdrawal underflow", async () => {
      // Initialize vault with small balance
      const initialBalance = new anchor.BN(100);
      
      await program.methods
        .vulnerableInitialize(initialBalance)
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([vulnerableVault, owner])
        .rpc();

      let vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Initial balance:", vaultAccount.balance.toString());

      // Attempt to withdraw more than the balance to cause underflow
      const underflowAmount = new anchor.BN(1000);
      
      await program.methods
        .vulnerableWithdraw(underflowAmount)
        .accounts({
          vault: vulnerableVault.publicKey,
          withdrawer: attacker.publicKey,
        })
        .signers([attacker])
        .rpc();

      vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Balance after underflow withdrawal:", vaultAccount.balance.toString());
      
      // In release mode, this would wrap around to a very large number
      // Demonstrating how underflow can create funds out of thin air
      expect(vaultAccount.balance.gt(initialBalance)).to.be.true;
    });

    it("should demonstrate overflow in interest calculation", async () => {
      // Initialize vault with large balance
      const largeBalance = new anchor.BN("9223372036854775807"); // Close to i64::MAX
      
      await program.methods
        .vulnerableInitialize(largeBalance)
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([vulnerableVault, owner])
        .rpc();

      let vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Initial balance:", vaultAccount.balance.toString());

      // Apply high interest rate that will cause multiplication overflow
      const highRate = new anchor.BN(5000); // 50% interest
      
      await program.methods
        .vulnerableApplyInterest(highRate)
        .accounts({
          vault: vulnerableVault.publicKey,
          authority: attacker.publicKey,
        })
        .signers([attacker])
        .rpc();

      vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Balance after interest overflow:", vaultAccount.balance.toString());
      
      // The multiplication overflow would cause unexpected balance
      expect(vaultAccount.balance.toString()).to.not.equal(
        largeBalance.add(largeBalance.mul(highRate).div(new anchor.BN(10000))).toString()
      );
    });

    it("should demonstrate batch deposit overflow accumulation", async () => {
      // Initialize vault
      const initialBalance = new anchor.BN(1000);
      
      await program.methods
        .vulnerableInitialize(initialBalance)
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([vulnerableVault, owner])
        .rpc();

      // Create array of large amounts that will overflow when accumulated
      const largeAmount = new anchor.BN("9223372036854775807");
      const amounts = [largeAmount, largeAmount, largeAmount];
      
      await program.methods
        .vulnerableBatchDeposit(amounts)
        .accounts({
          vault: vulnerableVault.publicKey,
          depositor: attacker.publicKey,
        })
        .signers([attacker])
        .rpc();

      const vaultAccount = await program.account.arithmeticVault.fetch(vulnerableVault.publicKey);
      console.log("Balance after batch overflow:", vaultAccount.balance.toString());
      
      // Multiple overflows would cause unpredictable balance
      expect(vaultAccount.balance.lt(initialBalance.add(largeAmount.mul(new anchor.BN(3))))).to.be.true;
    });
  });

  describe("Secure Implementation - Overflow Prevention", () => {
    it("should prevent deposit overflow with proper error handling", async () => {
      // Initialize secure vault with large balance
      const nearMaxBalance = new anchor.BN("18446744073709551615").sub(new anchor.BN(1000));
      
      await program.methods
        .secureInitialize(nearMaxBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Attempt deposit that would overflow - should fail with error
      const overflowAmount = new anchor.BN(2000);
      
      try {
        await program.methods
          .secureDeposit(overflowAmount)
          .accounts({
            vault: secureVault.publicKey,
            depositor: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();
        
        expect.fail("Expected transaction to fail due to overflow");
      } catch (error) {
        expect(error.toString()).to.include("ArithmeticOverflow");
        console.log("✓ Secure deposit correctly prevented overflow");
      }

      // Verify balance unchanged
      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal(nearMaxBalance.toString());
    });

    it("should prevent withdrawal underflow with balance validation", async () => {
      // Initialize secure vault with small balance
      const initialBalance = new anchor.BN(100);
      
      await program.methods
        .secureInitialize(initialBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Attempt withdrawal larger than balance - should fail
      const underflowAmount = new anchor.BN(1000);
      
      try {
        await program.methods
          .secureWithdraw(underflowAmount)
          .accounts({
            vault: secureVault.publicKey,
            withdrawer: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();
        
        expect.fail("Expected transaction to fail due to insufficient funds");
      } catch (error) {
        expect(error.toString()).to.include("InsufficientFunds");
        console.log("✓ Secure withdrawal correctly prevented underflow");
      }

      // Verify balance unchanged
      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal(initialBalance.toString());
    });

    it("should prevent interest calculation overflow", async () => {
      // Initialize secure vault with large balance
      const largeBalance = new anchor.BN("9223372036854775807");
      
      await program.methods
        .secureInitialize(largeBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Attempt high interest rate that would overflow - should fail
      const highRate = new anchor.BN(5000);
      
      try {
        await program.methods
          .secureApplyInterest(highRate)
          .accounts({
            vault: secureVault.publicKey,
            authority: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();
        
        expect.fail("Expected transaction to fail due to overflow");
      } catch (error) {
        expect(error.toString()).to.include("ArithmeticOverflow");
        console.log("✓ Secure interest calculation correctly prevented overflow");
      }

      // Verify balance unchanged
      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal(largeBalance.toString());
    });

    it("should prevent batch deposit overflow", async () => {
      // Initialize secure vault
      const initialBalance = new anchor.BN(1000);
      
      await program.methods
        .secureInitialize(initialBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Create amounts that would overflow when accumulated
      const largeAmount = new anchor.BN("9223372036854775807");
      const amounts = [largeAmount, largeAmount];
      
      try {
        await program.methods
          .secureBatchDeposit(amounts)
          .accounts({
            vault: secureVault.publicKey,
            depositor: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();
        
        expect.fail("Expected transaction to fail due to overflow");
      } catch (error) {
        expect(error.toString()).to.include("ArithmeticOverflow");
        console.log("✓ Secure batch deposit correctly prevented overflow");
      }

      // Verify balance unchanged
      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal(initialBalance.toString());
    });
  });

  describe("Boundary Condition Tests", () => {
    it("should handle maximum safe values correctly", async () => {
      // Test with u64::MAX - 1 to ensure we can still operate safely
      const maxSafeBalance = new anchor.BN("18446744073709551614"); // u64::MAX - 1
      
      await program.methods
        .secureInitialize(maxSafeBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Should be able to deposit 1 more
      await program.methods
        .secureDeposit(new anchor.BN(1))
        .accounts({
          vault: secureVault.publicKey,
          depositor: owner.publicKey,
        })
        .signers([owner])
        .rpc();

      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal("18446744073709551615"); // u64::MAX
      
      // But should fail to deposit any more
      try {
        await program.methods
          .secureDeposit(new anchor.BN(1))
          .accounts({
            vault: secureVault.publicKey,
            depositor: owner.publicKey,
          })
          .signers([owner])
          .rpc();
        
        expect.fail("Expected transaction to fail at u64::MAX + 1");
      } catch (error) {
        expect(error.toString()).to.include("ArithmeticOverflow");
        console.log("✓ Correctly prevented overflow at u64::MAX boundary");
      }
    });

    it("should handle minimum values and zero correctly", async () => {
      // Initialize with zero balance
      await program.methods
        .secureInitialize(new anchor.BN(0))
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Should fail to withdraw anything from zero balance
      try {
        await program.methods
          .secureWithdraw(new anchor.BN(1))
          .accounts({
            vault: secureVault.publicKey,
            withdrawer: owner.publicKey,
          })
          .signers([owner])
          .rpc();
        
        expect.fail("Expected transaction to fail with zero balance");
      } catch (error) {
        expect(error.toString()).to.include("InsufficientFunds");
        console.log("✓ Correctly prevented underflow at zero boundary");
      }

      // Should be able to deposit to zero balance
      await program.methods
        .secureDeposit(new anchor.BN(100))
        .accounts({
          vault: secureVault.publicKey,
          depositor: owner.publicKey,
        })
        .signers([owner])
        .rpc();

      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal("100");
    });
  });

  describe("Legitimate Operations", () => {
    it("should allow normal deposit and withdrawal operations", async () => {
      // Initialize with reasonable balance
      const initialBalance = new anchor.BN(1000);
      
      await program.methods
        .secureInitialize(initialBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Normal deposit
      await program.methods
        .secureDeposit(new anchor.BN(500))
        .accounts({
          vault: secureVault.publicKey,
          depositor: owner.publicKey,
        })
        .signers([owner])
        .rpc();

      let vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal("1500");

      // Normal withdrawal
      await program.methods
        .secureWithdraw(new anchor.BN(300))
        .accounts({
          vault: secureVault.publicKey,
          withdrawer: owner.publicKey,
        })
        .signers([owner])
        .rpc();

      vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal("1200");
      
      console.log("✓ Normal operations work correctly with secure implementation");
    });

    it("should apply reasonable interest rates safely", async () => {
      // Initialize with moderate balance
      const initialBalance = new anchor.BN(10000);
      
      await program.methods
        .secureInitialize(initialBalance)
        .accounts({
          vault: secureVault.publicKey,
          owner: owner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([secureVault, owner])
        .rpc();

      // Apply 5% interest (500 basis points)
      await program.methods
        .secureApplyInterest(new anchor.BN(500))
        .accounts({
          vault: secureVault.publicKey,
          authority: owner.publicKey,
        })
        .signers([owner])
        .rpc();

      const vaultAccount = await program.account.arithmeticVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toString()).to.equal("10500"); // 10000 + 5%
      
      console.log("✓ Interest calculation works correctly for reasonable rates");
    });
  });
});